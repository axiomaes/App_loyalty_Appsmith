{
  "gitSyncId": "68f1ea66301c3b6f3e13c5f4_f869ff6f-5f10-471e-b809-ab5d3b6d41d2",
  "id": "Dashboard_q_bond_assign_upsert",
  "pluginId": "postgres-plugin",
  "pluginType": "DB",
  "unpublishedAction": {
    "actionConfiguration": {
      "body": "-- q_bond_assign_upsert\n-- Params:\n--   {{ appsmith.store.businessId }} :: uuid  (implícito en v.bid)\n--   {{ this.params.customerId }}    :: uuid\n--   {{ this.params.planId }}        :: uuid\n\nWITH v AS (\n  SELECT\n    {{ appsmith.store.businessId }}::uuid AS bid,\n    {{ this.params.customerId }}::uuid     AS cid,\n    {{ this.params.planId }}::uuid         AS pid\n),\n\n-- Cliente válido (del mismo negocio y no eliminado)\ncust AS (\n  SELECT c.id\n  FROM public.\"Customer\" c\n  JOIN v ON c.id = v.cid AND c.\"businessId\" = v.bid\n  WHERE c.\"deletedAt\" IS NULL\n),\n\n-- Plan válido (del mismo negocio y activo)\nplan AS (\n  SELECT bp.id\n  FROM public.\"BondPlan\" bp\n  JOIN v ON bp.id = v.pid AND bp.\"businessId\" = v.bid\n  WHERE COALESCE(bp.\"isActive\", TRUE) = TRUE\n),\n\n-- Bond existente del cliente (si lo hay)\nexisting AS (\n  SELECT b.id, b.\"customerId\", b.\"planId\"\n  FROM public.\"Bond\" b\n  JOIN cust c ON c.id = b.\"customerId\"\n  LIMIT 1\n),\n\n-- UPDATE solo si hay bond y el plan cambia y el nuevo plan es válido\nupd AS (\n  UPDATE public.\"Bond\" b\n  SET \"planId\" = p.id,\n      \"updatedAt\" = NOW()\n  FROM plan p, existing e\n  WHERE b.id = e.id\n    AND e.\"planId\" <> p.id\n  RETURNING b.\"id\", b.\"customerId\", b.\"planId\", 'updated'::text AS op\n),\n\n-- INSERT solo si no existía bond y cliente/plan son válidos\nins AS (\n  INSERT INTO public.\"Bond\" (\"id\", \"customerId\", \"planId\", \"startedAt\", \"createdAt\", \"updatedAt\")\n  SELECT uuid_generate_v4(), c.id, p.id, NOW(), NOW(), NOW()\n  FROM cust c, plan p\n  WHERE NOT EXISTS (SELECT 1 FROM existing)\n  RETURNING \"id\", \"customerId\", \"planId\", 'inserted'::text AS op\n),\n\n-- Fila resultante preferente: updated > inserted > existente (noop)\npicked AS (\n  SELECT * FROM upd\n  UNION ALL\n  SELECT * FROM ins\n  UNION ALL\n  SELECT e.id, e.\"customerId\", e.\"planId\", 'noop'::text AS op\n  FROM existing e\n  LIMIT 1\n)\n\nSELECT\n  (SELECT CASE WHEN EXISTS(SELECT 1 FROM cust) THEN 1 ELSE 0 END) AS has_customer,\n  (SELECT CASE WHEN EXISTS(SELECT 1 FROM plan) THEN 1 ELSE 0 END) AS has_plan,\n  p.id,\n  p.\"customerId\",\n  p.\"planId\",\n  p.op\nFROM picked p;\n",
      "encodeParamsToggle": true,
      "paginationType": "NONE",
      "pluginSpecifiedTemplates": [
        {
          "value": true
        }
      ],
      "timeoutInMillisecond": 10000
    },
    "confirmBeforeExecute": false,
    "datasource": {
      "id": "AxiomaDB",
      "isAutoGenerated": false,
      "name": "AxiomaDB",
      "pluginId": "postgres-plugin"
    },
    "dynamicBindingPathList": [
      {
        "key": "body"
      }
    ],
    "name": "q_bond_assign_upsert",
    "pageId": "Dashboard",
    "runBehaviour": "MANUAL",
    "userSetOnLoad": false
  }
}